

#######################################
# PARSE RESULT
#######################################

class ParseResult:
    """Contient le résultat d'une analyse syntaxique, incluant les erreurs éventuelles."""
    def __init__(self):
        self.error = None
        self.node = None

    def register(self, res):
        """Enregistre un résultat, récupère le nœud si succès."""
        if isinstance(res, ParseResult):
            if res.error: self.error = res.error
            return res.node
        return res

    def success(self, node):
        """Indique une réussite de parsing avec un nœud."""
        self.node = node
        return self

    def failure(self, error):
        """Indique un échec de parsing avec une erreur."""
        self.error = error
        return self

#######################################
# PARSER
#######################################

class Parser:
    """Analyseur syntaxique pour construire un AST à partir des tokens draw++."""
    
    def __init__(self, tokens):
        self.tokens = tokens
        self.tok_idx = -1
        self.next()

    def next(self):
        """Avance au token suivant."""
        self.tok_idx += 1
        self.current_tok = self.tokens[self.tok_idx] if self.tok_idx < len(self.tokens) else None
        return self.current_tok

    def parse(self):
        """Analyse une liste d'instructions et génère l'AST complet."""
        res = ParseResult()
        instructions = []

        while self.current_tok.type != SYMBOL_TOKENS['EOF']:
            instr = self.parse_instruction()
            if instr.error: 
                return instr
            instructions.append(instr.node)
            self.next()

        return res.success(instructions)

    def parse_instruction(self):
        """Identifie et analyse une instruction spécifique."""
        tok = self.current_tok
        
        if tok.type == LANG_TOKENS['CURSOR']:
            return self.parse_cursor()
        elif tok.type == LANG_TOKENS['MOVE']:
            return self.parse_move()
        elif tok.type == LANG_TOKENS['ROTATE']:
            return self.parse_rotate()
        elif tok.type == LANG_TOKENS['DRAW']:
            return self.parse_draw()
        elif tok.type == LANG_TOKENS['IF']:
            return self.parse_if()

        return ParseResult().failure(InvalidSyntaxError(tok.pos_start, tok.pos_end, "Instruction invalide"))

    def parse_cursor(self):
        """Analyse l'instruction de création d'un curseur."""
        res = ParseResult()
        self.next()

        if self.current_tok.type != USER_TOKENS['IDENTIFIER']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "Nom de curseur attendu"))

        cursor_name = self.current_tok.value
        self.next()
        
        if self.current_tok.type != SYMBOL_TOKENS['LPAREN']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "'(' attendu"))
        
        if(self.next() == USER_TOKENS['INT'] or USER_TOKENS['FLOAT']):
            x = self.current_tok.value
        
        self.next()
        if(self.current_tok.type != SYMBOL_TOKENS['COMMA']):
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "',' attendu"))

        if(self.next() == USER_TOKENS['INT'] or USER_TOKENS['FLOAT']):
            y = self.current_tok.value
            
        self.next()
        
        return res.success(CursorNode(cursor_name, x, y))

    def parse_move(self):
        """Analyse l'instruction MOVE pour déplacer un curseur."""
        res = ParseResult()
        self.next()
        
        if self.current_tok.type != USER_TOKENS['IDENTIFIER']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "Nom de curseur attendu"))
        
        cursor_name = self.current_tok.value
        self.next()
        
        if self.current_tok.type != SYMBOL_TOKENS['LPAREN']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "'(' attendu"))
        
        self.next()
        distance = self.current_tok.value
        self.next()  
        
        if self.current_tok.type != SYMBOL_TOKENS['RPAREN']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "')' attendu"))
        
        return res.success(MoveNode(cursor_name, distance))

    def parse_rotate(self):
        """Analyse l'instruction ROTATE pour faire pivoter un curseur."""
        res = ParseResult()
        self.next()
        
        if self.current_tok.type != USER_TOKENS['IDENTIFIER']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "Nom de curseur attendu"))
        
        cursor_name = self.current_tok.value
        self.next()
        
        if self.current_tok.type != SYMBOL_TOKENS['LPAREN']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "'(' attendu"))
        
        self.next()
        angle = self.current_tok.value
        self.next()
        
        if self.current_tok.type != SYMBOL_TOKENS['RPAREN']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "')' attendu"))
        
        return res.success(RotateNode(cursor_name, angle))

    def parse_draw(self):
        """Analyse l'instruction DRAW pour dessiner une forme."""
        res = ParseResult()
        self.next()
        
        if self.current_tok.type != USER_TOKENS['IDENTIFIER']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "Nom de forme attendu"))
        
        shape = self.current_tok.value
        self.next()
        
        args = []
        
        if self.current_tok.type != SYMBOL_TOKENS['LPAREN']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "'(' attendu"))
        
        self.next()
        while self.current_tok.type != SYMBOL_TOKENS['RPAREN']:
            args.append(self.current_tok.value)
            self.next()
        
        return res.success(DrawNode(shape, *args))

    def parse_if(self):
        """Analyse une instruction IF pour une condition."""
        res = ParseResult()
        self.next()

        condition = res.register(self.expression())
        if res.error: return res

        if self.current_tok.type != SYMBOL_TOKENS['LBRACE']:
            return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "'{' attendu après IF"))
        
        self.next()
        true_branch = res.register(self.statements())
        if res.error: return res

        false_branch = None
        if self.current_tok.type == LANG_TOKENS['ELSE']:
            self.next()
            if self.current_tok.type != SYMBOL_TOKENS['LBRACE']:
                return res.failure(InvalidSyntaxError(self.current_tok.pos_start, self.current_tok.pos_end, "'{' attendu après ELSE"))
            self.next()
            false_branch = res.register(self.statements())
            if res.error: return res

        return res.success(IfNode(condition, true_branch, false_branch))