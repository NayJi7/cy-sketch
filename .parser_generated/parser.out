Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANIMATE
    COLON
    CURSOR
    DO
    LBRACKET
    NOT
    OR
    RBRACKET

Grammar

Rule 0     S' -> programme
Rule 1     programme -> instruction
Rule 2     programme -> programme instruction
Rule 3     instruction -> dessin
Rule 4     instruction -> deplacement
Rule 5     instruction -> rotation
Rule 6     instruction -> couleur
Rule 7     instruction -> assignation
Rule 8     instruction -> modification
Rule 9     instruction -> conditionnelle
Rule 10    instruction -> boucle
Rule 11    instruction -> bloc
Rule 12    dessin -> DRAW forme LPAREN parametres RPAREN
Rule 13    forme -> LINE
Rule 14    forme -> CIRCLE
Rule 15    forme -> SQUARE
Rule 16    forme -> ARC
Rule 17    forme -> POINT
Rule 18    parametres -> parametres COMMA arg
Rule 19    parametres -> arg
Rule 20    arg -> NUMBER
Rule 21    arg -> IDENTIFIER
Rule 22    arg -> STRING
Rule 23    arg -> BOOLEAN
Rule 24    arg -> expression_arithmetic
Rule 25    expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic
Rule 26    expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic
Rule 27    expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic
Rule 28    expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic
Rule 29    expression_arithmetic -> LPAREN expression_arithmetic RPAREN
Rule 30    expression_arithmetic -> NUMBER
Rule 31    expression_arithmetic -> IDENTIFIER
Rule 32    deplacement -> MOVE LPAREN arg COMMA arg RPAREN
Rule 33    rotation -> ROTATE LPAREN arg RPAREN
Rule 34    couleur -> COLOR LPAREN arg RPAREN
Rule 35    assignation -> VARIABLE IDENTIFIER EQUALS arg
Rule 36    modification -> IDENTIFIER EQUALS arg
Rule 37    valeur -> NUMBER
Rule 38    valeur -> IDENTIFIER
Rule 39    valeur -> STRING
Rule 40    valeur -> BOOLEAN
Rule 41    bloc -> LBRACE programme RBRACE
Rule 42    conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc
Rule 43    conditionnelle -> IF LPAREN expression_logique RPAREN bloc
Rule 44    expression_logique -> valeur operateur_comparaison valeur
Rule 45    expression_logique -> valeur operateur_comparaison BOOLEAN
Rule 46    expression_logique -> BOOLEAN operateur_comparaison valeur
Rule 47    expression_logique -> BOOLEAN
Rule 48    operateur_comparaison -> EQ
Rule 49    operateur_comparaison -> NEQ
Rule 50    operateur_comparaison -> LT
Rule 51    operateur_comparaison -> GT
Rule 52    operateur_comparaison -> LE
Rule 53    operateur_comparaison -> GE
Rule 54    boucle -> WHILE LPAREN expression_logique RPAREN bloc
Rule 55    boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc

Terminals, with rules where they appear

AND                  : 
ANIMATE              : 
ARC                  : 16
BOOLEAN              : 23 40 45 46 47
CIRCLE               : 14
COLON                : 
COLOR                : 34
COMMA                : 18 32
CURSOR               : 
DIVIDE               : 28
DO                   : 
DRAW                 : 12
ELSE                 : 42
EQ                   : 48
EQUALS               : 35 36
FOR                  : 55
GE                   : 53
GT                   : 51
IDENTIFIER           : 21 31 35 36 38
IF                   : 42 43
LBRACE               : 41
LBRACKET             : 
LE                   : 52
LINE                 : 13
LPAREN               : 12 29 32 33 34 42 43 54 55
LT                   : 50
MINUS                : 26
MOVE                 : 32
NEQ                  : 49
NOT                  : 
NUMBER               : 20 30 37
OR                   : 
PLUS                 : 25
POINT                : 17
RBRACE               : 41
RBRACKET             : 
ROTATE               : 33
RPAREN               : 12 29 32 33 34 42 43 54 55
SEMICOLON            : 55 55
SQUARE               : 15
STRING               : 22 39
TIMES                : 27
VARIABLE             : 35
WHILE                : 54
error                : 

Nonterminals, with rules where they appear

arg                  : 18 19 32 32 33 34 35 36
assignation          : 7 55
bloc                 : 11 42 42 43 54 55
boucle               : 10
conditionnelle       : 9
couleur              : 6
deplacement          : 4
dessin               : 3
expression_arithmetic : 24 25 25 26 26 27 27 28 28 29
expression_logique   : 42 43 54 55
forme                : 12
instruction          : 1 2
modification         : 8 55
operateur_comparaison : 44 45 46
parametres           : 12 18
programme            : 2 41 0
rotation             : 5
valeur               : 44 44 45 46

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . instruction
    (2) programme -> . programme instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . WHILE LPAREN expression_logique RPAREN bloc
    (55) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    LBRACE          shift and go to state 21

    programme                      shift and go to state 1
    instruction                    shift and go to state 2
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 1

    (0) S' -> programme .
    (2) programme -> programme . instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . WHILE LPAREN expression_logique RPAREN bloc
    (55) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    LBRACE          shift and go to state 21

    instruction                    shift and go to state 22
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 2

    (1) programme -> instruction .

    DRAW            reduce using rule 1 (programme -> instruction .)
    MOVE            reduce using rule 1 (programme -> instruction .)
    ROTATE          reduce using rule 1 (programme -> instruction .)
    COLOR           reduce using rule 1 (programme -> instruction .)
    VARIABLE        reduce using rule 1 (programme -> instruction .)
    IDENTIFIER      reduce using rule 1 (programme -> instruction .)
    IF              reduce using rule 1 (programme -> instruction .)
    WHILE           reduce using rule 1 (programme -> instruction .)
    FOR             reduce using rule 1 (programme -> instruction .)
    LBRACE          reduce using rule 1 (programme -> instruction .)
    $end            reduce using rule 1 (programme -> instruction .)
    RBRACE          reduce using rule 1 (programme -> instruction .)


state 3

    (3) instruction -> dessin .

    DRAW            reduce using rule 3 (instruction -> dessin .)
    MOVE            reduce using rule 3 (instruction -> dessin .)
    ROTATE          reduce using rule 3 (instruction -> dessin .)
    COLOR           reduce using rule 3 (instruction -> dessin .)
    VARIABLE        reduce using rule 3 (instruction -> dessin .)
    IDENTIFIER      reduce using rule 3 (instruction -> dessin .)
    IF              reduce using rule 3 (instruction -> dessin .)
    WHILE           reduce using rule 3 (instruction -> dessin .)
    FOR             reduce using rule 3 (instruction -> dessin .)
    LBRACE          reduce using rule 3 (instruction -> dessin .)
    $end            reduce using rule 3 (instruction -> dessin .)
    RBRACE          reduce using rule 3 (instruction -> dessin .)


state 4

    (4) instruction -> deplacement .

    DRAW            reduce using rule 4 (instruction -> deplacement .)
    MOVE            reduce using rule 4 (instruction -> deplacement .)
    ROTATE          reduce using rule 4 (instruction -> deplacement .)
    COLOR           reduce using rule 4 (instruction -> deplacement .)
    VARIABLE        reduce using rule 4 (instruction -> deplacement .)
    IDENTIFIER      reduce using rule 4 (instruction -> deplacement .)
    IF              reduce using rule 4 (instruction -> deplacement .)
    WHILE           reduce using rule 4 (instruction -> deplacement .)
    FOR             reduce using rule 4 (instruction -> deplacement .)
    LBRACE          reduce using rule 4 (instruction -> deplacement .)
    $end            reduce using rule 4 (instruction -> deplacement .)
    RBRACE          reduce using rule 4 (instruction -> deplacement .)


state 5

    (5) instruction -> rotation .

    DRAW            reduce using rule 5 (instruction -> rotation .)
    MOVE            reduce using rule 5 (instruction -> rotation .)
    ROTATE          reduce using rule 5 (instruction -> rotation .)
    COLOR           reduce using rule 5 (instruction -> rotation .)
    VARIABLE        reduce using rule 5 (instruction -> rotation .)
    IDENTIFIER      reduce using rule 5 (instruction -> rotation .)
    IF              reduce using rule 5 (instruction -> rotation .)
    WHILE           reduce using rule 5 (instruction -> rotation .)
    FOR             reduce using rule 5 (instruction -> rotation .)
    LBRACE          reduce using rule 5 (instruction -> rotation .)
    $end            reduce using rule 5 (instruction -> rotation .)
    RBRACE          reduce using rule 5 (instruction -> rotation .)


state 6

    (6) instruction -> couleur .

    DRAW            reduce using rule 6 (instruction -> couleur .)
    MOVE            reduce using rule 6 (instruction -> couleur .)
    ROTATE          reduce using rule 6 (instruction -> couleur .)
    COLOR           reduce using rule 6 (instruction -> couleur .)
    VARIABLE        reduce using rule 6 (instruction -> couleur .)
    IDENTIFIER      reduce using rule 6 (instruction -> couleur .)
    IF              reduce using rule 6 (instruction -> couleur .)
    WHILE           reduce using rule 6 (instruction -> couleur .)
    FOR             reduce using rule 6 (instruction -> couleur .)
    LBRACE          reduce using rule 6 (instruction -> couleur .)
    $end            reduce using rule 6 (instruction -> couleur .)
    RBRACE          reduce using rule 6 (instruction -> couleur .)


state 7

    (7) instruction -> assignation .

    DRAW            reduce using rule 7 (instruction -> assignation .)
    MOVE            reduce using rule 7 (instruction -> assignation .)
    ROTATE          reduce using rule 7 (instruction -> assignation .)
    COLOR           reduce using rule 7 (instruction -> assignation .)
    VARIABLE        reduce using rule 7 (instruction -> assignation .)
    IDENTIFIER      reduce using rule 7 (instruction -> assignation .)
    IF              reduce using rule 7 (instruction -> assignation .)
    WHILE           reduce using rule 7 (instruction -> assignation .)
    FOR             reduce using rule 7 (instruction -> assignation .)
    LBRACE          reduce using rule 7 (instruction -> assignation .)
    $end            reduce using rule 7 (instruction -> assignation .)
    RBRACE          reduce using rule 7 (instruction -> assignation .)


state 8

    (8) instruction -> modification .

    DRAW            reduce using rule 8 (instruction -> modification .)
    MOVE            reduce using rule 8 (instruction -> modification .)
    ROTATE          reduce using rule 8 (instruction -> modification .)
    COLOR           reduce using rule 8 (instruction -> modification .)
    VARIABLE        reduce using rule 8 (instruction -> modification .)
    IDENTIFIER      reduce using rule 8 (instruction -> modification .)
    IF              reduce using rule 8 (instruction -> modification .)
    WHILE           reduce using rule 8 (instruction -> modification .)
    FOR             reduce using rule 8 (instruction -> modification .)
    LBRACE          reduce using rule 8 (instruction -> modification .)
    $end            reduce using rule 8 (instruction -> modification .)
    RBRACE          reduce using rule 8 (instruction -> modification .)


state 9

    (9) instruction -> conditionnelle .

    DRAW            reduce using rule 9 (instruction -> conditionnelle .)
    MOVE            reduce using rule 9 (instruction -> conditionnelle .)
    ROTATE          reduce using rule 9 (instruction -> conditionnelle .)
    COLOR           reduce using rule 9 (instruction -> conditionnelle .)
    VARIABLE        reduce using rule 9 (instruction -> conditionnelle .)
    IDENTIFIER      reduce using rule 9 (instruction -> conditionnelle .)
    IF              reduce using rule 9 (instruction -> conditionnelle .)
    WHILE           reduce using rule 9 (instruction -> conditionnelle .)
    FOR             reduce using rule 9 (instruction -> conditionnelle .)
    LBRACE          reduce using rule 9 (instruction -> conditionnelle .)
    $end            reduce using rule 9 (instruction -> conditionnelle .)
    RBRACE          reduce using rule 9 (instruction -> conditionnelle .)


state 10

    (10) instruction -> boucle .

    DRAW            reduce using rule 10 (instruction -> boucle .)
    MOVE            reduce using rule 10 (instruction -> boucle .)
    ROTATE          reduce using rule 10 (instruction -> boucle .)
    COLOR           reduce using rule 10 (instruction -> boucle .)
    VARIABLE        reduce using rule 10 (instruction -> boucle .)
    IDENTIFIER      reduce using rule 10 (instruction -> boucle .)
    IF              reduce using rule 10 (instruction -> boucle .)
    WHILE           reduce using rule 10 (instruction -> boucle .)
    FOR             reduce using rule 10 (instruction -> boucle .)
    LBRACE          reduce using rule 10 (instruction -> boucle .)
    $end            reduce using rule 10 (instruction -> boucle .)
    RBRACE          reduce using rule 10 (instruction -> boucle .)


state 11

    (11) instruction -> bloc .

    DRAW            reduce using rule 11 (instruction -> bloc .)
    MOVE            reduce using rule 11 (instruction -> bloc .)
    ROTATE          reduce using rule 11 (instruction -> bloc .)
    COLOR           reduce using rule 11 (instruction -> bloc .)
    VARIABLE        reduce using rule 11 (instruction -> bloc .)
    IDENTIFIER      reduce using rule 11 (instruction -> bloc .)
    IF              reduce using rule 11 (instruction -> bloc .)
    WHILE           reduce using rule 11 (instruction -> bloc .)
    FOR             reduce using rule 11 (instruction -> bloc .)
    LBRACE          reduce using rule 11 (instruction -> bloc .)
    $end            reduce using rule 11 (instruction -> bloc .)
    RBRACE          reduce using rule 11 (instruction -> bloc .)


state 12

    (12) dessin -> DRAW . forme LPAREN parametres RPAREN
    (13) forme -> . LINE
    (14) forme -> . CIRCLE
    (15) forme -> . SQUARE
    (16) forme -> . ARC
    (17) forme -> . POINT

    LINE            shift and go to state 24
    CIRCLE          shift and go to state 25
    SQUARE          shift and go to state 26
    ARC             shift and go to state 27
    POINT           shift and go to state 28

    forme                          shift and go to state 23

state 13

    (32) deplacement -> MOVE . LPAREN arg COMMA arg RPAREN

    LPAREN          shift and go to state 29


state 14

    (33) rotation -> ROTATE . LPAREN arg RPAREN

    LPAREN          shift and go to state 30


state 15

    (34) couleur -> COLOR . LPAREN arg RPAREN

    LPAREN          shift and go to state 31


state 16

    (35) assignation -> VARIABLE . IDENTIFIER EQUALS arg

    IDENTIFIER      shift and go to state 32


state 17

    (36) modification -> IDENTIFIER . EQUALS arg

    EQUALS          shift and go to state 33


state 18

    (42) conditionnelle -> IF . LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> IF . LPAREN expression_logique RPAREN bloc

    LPAREN          shift and go to state 34


state 19

    (54) boucle -> WHILE . LPAREN expression_logique RPAREN bloc

    LPAREN          shift and go to state 35


state 20

    (55) boucle -> FOR . LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc

    LPAREN          shift and go to state 36


state 21

    (41) bloc -> LBRACE . programme RBRACE
    (1) programme -> . instruction
    (2) programme -> . programme instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . WHILE LPAREN expression_logique RPAREN bloc
    (55) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    LBRACE          shift and go to state 21

    programme                      shift and go to state 37
    instruction                    shift and go to state 2
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 22

    (2) programme -> programme instruction .

    DRAW            reduce using rule 2 (programme -> programme instruction .)
    MOVE            reduce using rule 2 (programme -> programme instruction .)
    ROTATE          reduce using rule 2 (programme -> programme instruction .)
    COLOR           reduce using rule 2 (programme -> programme instruction .)
    VARIABLE        reduce using rule 2 (programme -> programme instruction .)
    IDENTIFIER      reduce using rule 2 (programme -> programme instruction .)
    IF              reduce using rule 2 (programme -> programme instruction .)
    WHILE           reduce using rule 2 (programme -> programme instruction .)
    FOR             reduce using rule 2 (programme -> programme instruction .)
    LBRACE          reduce using rule 2 (programme -> programme instruction .)
    $end            reduce using rule 2 (programme -> programme instruction .)
    RBRACE          reduce using rule 2 (programme -> programme instruction .)


state 23

    (12) dessin -> DRAW forme . LPAREN parametres RPAREN

    LPAREN          shift and go to state 38


state 24

    (13) forme -> LINE .

    LPAREN          reduce using rule 13 (forme -> LINE .)


state 25

    (14) forme -> CIRCLE .

    LPAREN          reduce using rule 14 (forme -> CIRCLE .)


state 26

    (15) forme -> SQUARE .

    LPAREN          reduce using rule 15 (forme -> SQUARE .)


state 27

    (16) forme -> ARC .

    LPAREN          reduce using rule 16 (forme -> ARC .)


state 28

    (17) forme -> POINT .

    LPAREN          reduce using rule 17 (forme -> POINT .)


state 29

    (32) deplacement -> MOVE LPAREN . arg COMMA arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    arg                            shift and go to state 40
    expression_arithmetic          shift and go to state 45

state 30

    (33) rotation -> ROTATE LPAREN . arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    arg                            shift and go to state 46
    expression_arithmetic          shift and go to state 45

state 31

    (34) couleur -> COLOR LPAREN . arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    arg                            shift and go to state 47
    expression_arithmetic          shift and go to state 45

state 32

    (35) assignation -> VARIABLE IDENTIFIER . EQUALS arg

    EQUALS          shift and go to state 48


state 33

    (36) modification -> IDENTIFIER EQUALS . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    arg                            shift and go to state 49
    expression_arithmetic          shift and go to state 45

state 34

    (42) conditionnelle -> IF LPAREN . expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> IF LPAREN . expression_logique RPAREN bloc
    (44) expression_logique -> . valeur operateur_comparaison valeur
    (45) expression_logique -> . valeur operateur_comparaison BOOLEAN
    (46) expression_logique -> . BOOLEAN operateur_comparaison valeur
    (47) expression_logique -> . BOOLEAN
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    BOOLEAN         shift and go to state 52
    NUMBER          shift and go to state 53
    IDENTIFIER      shift and go to state 54
    STRING          shift and go to state 55

    expression_logique             shift and go to state 50
    valeur                         shift and go to state 51

state 35

    (54) boucle -> WHILE LPAREN . expression_logique RPAREN bloc
    (44) expression_logique -> . valeur operateur_comparaison valeur
    (45) expression_logique -> . valeur operateur_comparaison BOOLEAN
    (46) expression_logique -> . BOOLEAN operateur_comparaison valeur
    (47) expression_logique -> . BOOLEAN
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    BOOLEAN         shift and go to state 52
    NUMBER          shift and go to state 53
    IDENTIFIER      shift and go to state 54
    STRING          shift and go to state 55

    expression_logique             shift and go to state 56
    valeur                         shift and go to state 51

state 36

    (55) boucle -> FOR LPAREN . assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg

    VARIABLE        shift and go to state 16

    assignation                    shift and go to state 57

state 37

    (41) bloc -> LBRACE programme . RBRACE
    (2) programme -> programme . instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . WHILE LPAREN expression_logique RPAREN bloc
    (55) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    RBRACE          shift and go to state 58
    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FOR             shift and go to state 20
    LBRACE          shift and go to state 21

    instruction                    shift and go to state 22
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 38

    (12) dessin -> DRAW forme LPAREN . parametres RPAREN
    (18) parametres -> . parametres COMMA arg
    (19) parametres -> . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    parametres                     shift and go to state 59
    arg                            shift and go to state 60
    expression_arithmetic          shift and go to state 45

state 39

    (29) expression_arithmetic -> LPAREN . expression_arithmetic RPAREN
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 62
    IDENTIFIER      shift and go to state 63

    expression_arithmetic          shift and go to state 61

state 40

    (32) deplacement -> MOVE LPAREN arg . COMMA arg RPAREN

    COMMA           shift and go to state 64


state 41

    (20) arg -> NUMBER .
    (30) expression_arithmetic -> NUMBER .

  ! reduce/reduce conflict for COMMA resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for DRAW resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for MOVE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for ROTATE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for COLOR resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for IF resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for WHILE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for FOR resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (arg -> NUMBER .)
    COMMA           reduce using rule 20 (arg -> NUMBER .)
    RPAREN          reduce using rule 20 (arg -> NUMBER .)
    DRAW            reduce using rule 20 (arg -> NUMBER .)
    MOVE            reduce using rule 20 (arg -> NUMBER .)
    ROTATE          reduce using rule 20 (arg -> NUMBER .)
    COLOR           reduce using rule 20 (arg -> NUMBER .)
    VARIABLE        reduce using rule 20 (arg -> NUMBER .)
    IDENTIFIER      reduce using rule 20 (arg -> NUMBER .)
    IF              reduce using rule 20 (arg -> NUMBER .)
    WHILE           reduce using rule 20 (arg -> NUMBER .)
    FOR             reduce using rule 20 (arg -> NUMBER .)
    LBRACE          reduce using rule 20 (arg -> NUMBER .)
    $end            reduce using rule 20 (arg -> NUMBER .)
    RBRACE          reduce using rule 20 (arg -> NUMBER .)
    SEMICOLON       reduce using rule 20 (arg -> NUMBER .)
    PLUS            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    MINUS           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    TIMES           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    DIVIDE          reduce using rule 30 (expression_arithmetic -> NUMBER .)

  ! COMMA           [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! DRAW            [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! MOVE            [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! ROTATE          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! COLOR           [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! VARIABLE        [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! IDENTIFIER      [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! IF              [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! WHILE           [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! FOR             [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! LBRACE          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! $end            [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! RBRACE          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! SEMICOLON       [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]


state 42

    (21) arg -> IDENTIFIER .
    (31) expression_arithmetic -> IDENTIFIER .

  ! reduce/reduce conflict for COMMA resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for DRAW resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for MOVE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for ROTATE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for COLOR resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for FOR resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (arg -> IDENTIFIER .)
    COMMA           reduce using rule 21 (arg -> IDENTIFIER .)
    RPAREN          reduce using rule 21 (arg -> IDENTIFIER .)
    DRAW            reduce using rule 21 (arg -> IDENTIFIER .)
    MOVE            reduce using rule 21 (arg -> IDENTIFIER .)
    ROTATE          reduce using rule 21 (arg -> IDENTIFIER .)
    COLOR           reduce using rule 21 (arg -> IDENTIFIER .)
    VARIABLE        reduce using rule 21 (arg -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 21 (arg -> IDENTIFIER .)
    IF              reduce using rule 21 (arg -> IDENTIFIER .)
    WHILE           reduce using rule 21 (arg -> IDENTIFIER .)
    FOR             reduce using rule 21 (arg -> IDENTIFIER .)
    LBRACE          reduce using rule 21 (arg -> IDENTIFIER .)
    $end            reduce using rule 21 (arg -> IDENTIFIER .)
    RBRACE          reduce using rule 21 (arg -> IDENTIFIER .)
    SEMICOLON       reduce using rule 21 (arg -> IDENTIFIER .)
    PLUS            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    MINUS           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    TIMES           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    DIVIDE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)

  ! COMMA           [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! RPAREN          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! DRAW            [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! MOVE            [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! ROTATE          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! COLOR           [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! VARIABLE        [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! FOR             [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! $end            [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! RBRACE          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! SEMICOLON       [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]


state 43

    (22) arg -> STRING .

    COMMA           reduce using rule 22 (arg -> STRING .)
    RPAREN          reduce using rule 22 (arg -> STRING .)
    DRAW            reduce using rule 22 (arg -> STRING .)
    MOVE            reduce using rule 22 (arg -> STRING .)
    ROTATE          reduce using rule 22 (arg -> STRING .)
    COLOR           reduce using rule 22 (arg -> STRING .)
    VARIABLE        reduce using rule 22 (arg -> STRING .)
    IDENTIFIER      reduce using rule 22 (arg -> STRING .)
    IF              reduce using rule 22 (arg -> STRING .)
    WHILE           reduce using rule 22 (arg -> STRING .)
    FOR             reduce using rule 22 (arg -> STRING .)
    LBRACE          reduce using rule 22 (arg -> STRING .)
    $end            reduce using rule 22 (arg -> STRING .)
    RBRACE          reduce using rule 22 (arg -> STRING .)
    SEMICOLON       reduce using rule 22 (arg -> STRING .)


state 44

    (23) arg -> BOOLEAN .

    COMMA           reduce using rule 23 (arg -> BOOLEAN .)
    RPAREN          reduce using rule 23 (arg -> BOOLEAN .)
    DRAW            reduce using rule 23 (arg -> BOOLEAN .)
    MOVE            reduce using rule 23 (arg -> BOOLEAN .)
    ROTATE          reduce using rule 23 (arg -> BOOLEAN .)
    COLOR           reduce using rule 23 (arg -> BOOLEAN .)
    VARIABLE        reduce using rule 23 (arg -> BOOLEAN .)
    IDENTIFIER      reduce using rule 23 (arg -> BOOLEAN .)
    IF              reduce using rule 23 (arg -> BOOLEAN .)
    WHILE           reduce using rule 23 (arg -> BOOLEAN .)
    FOR             reduce using rule 23 (arg -> BOOLEAN .)
    LBRACE          reduce using rule 23 (arg -> BOOLEAN .)
    $end            reduce using rule 23 (arg -> BOOLEAN .)
    RBRACE          reduce using rule 23 (arg -> BOOLEAN .)
    SEMICOLON       reduce using rule 23 (arg -> BOOLEAN .)


state 45

    (24) arg -> expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

    COMMA           reduce using rule 24 (arg -> expression_arithmetic .)
    RPAREN          reduce using rule 24 (arg -> expression_arithmetic .)
    DRAW            reduce using rule 24 (arg -> expression_arithmetic .)
    MOVE            reduce using rule 24 (arg -> expression_arithmetic .)
    ROTATE          reduce using rule 24 (arg -> expression_arithmetic .)
    COLOR           reduce using rule 24 (arg -> expression_arithmetic .)
    VARIABLE        reduce using rule 24 (arg -> expression_arithmetic .)
    IDENTIFIER      reduce using rule 24 (arg -> expression_arithmetic .)
    IF              reduce using rule 24 (arg -> expression_arithmetic .)
    WHILE           reduce using rule 24 (arg -> expression_arithmetic .)
    FOR             reduce using rule 24 (arg -> expression_arithmetic .)
    LBRACE          reduce using rule 24 (arg -> expression_arithmetic .)
    $end            reduce using rule 24 (arg -> expression_arithmetic .)
    RBRACE          reduce using rule 24 (arg -> expression_arithmetic .)
    SEMICOLON       reduce using rule 24 (arg -> expression_arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68


state 46

    (33) rotation -> ROTATE LPAREN arg . RPAREN

    RPAREN          shift and go to state 69


state 47

    (34) couleur -> COLOR LPAREN arg . RPAREN

    RPAREN          shift and go to state 70


state 48

    (35) assignation -> VARIABLE IDENTIFIER EQUALS . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    arg                            shift and go to state 71
    expression_arithmetic          shift and go to state 45

state 49

    (36) modification -> IDENTIFIER EQUALS arg .

    DRAW            reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    MOVE            reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    ROTATE          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    COLOR           reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    VARIABLE        reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    IDENTIFIER      reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    IF              reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    WHILE           reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    FOR             reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    LBRACE          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    $end            reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    RBRACE          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    RPAREN          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)


state 50

    (42) conditionnelle -> IF LPAREN expression_logique . RPAREN bloc ELSE bloc
    (43) conditionnelle -> IF LPAREN expression_logique . RPAREN bloc

    RPAREN          shift and go to state 72


state 51

    (44) expression_logique -> valeur . operateur_comparaison valeur
    (45) expression_logique -> valeur . operateur_comparaison BOOLEAN
    (48) operateur_comparaison -> . EQ
    (49) operateur_comparaison -> . NEQ
    (50) operateur_comparaison -> . LT
    (51) operateur_comparaison -> . GT
    (52) operateur_comparaison -> . LE
    (53) operateur_comparaison -> . GE

    EQ              shift and go to state 74
    NEQ             shift and go to state 75
    LT              shift and go to state 76
    GT              shift and go to state 77
    LE              shift and go to state 78
    GE              shift and go to state 79

    operateur_comparaison          shift and go to state 73

state 52

    (46) expression_logique -> BOOLEAN . operateur_comparaison valeur
    (47) expression_logique -> BOOLEAN .
    (40) valeur -> BOOLEAN .
    (48) operateur_comparaison -> . EQ
    (49) operateur_comparaison -> . NEQ
    (50) operateur_comparaison -> . LT
    (51) operateur_comparaison -> . GT
    (52) operateur_comparaison -> . LE
    (53) operateur_comparaison -> . GE

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RPAREN          reduce using rule 47 (expression_logique -> BOOLEAN .)
    SEMICOLON       reduce using rule 47 (expression_logique -> BOOLEAN .)
    EQ              shift and go to state 74
    NEQ             shift and go to state 75
    LT              shift and go to state 76
    GT              shift and go to state 77
    LE              shift and go to state 78
    GE              shift and go to state 79

  ! EQ              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! NEQ             [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! LT              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! GT              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! LE              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! GE              [ reduce using rule 40 (valeur -> BOOLEAN .) ]

    operateur_comparaison          shift and go to state 80

state 53

    (37) valeur -> NUMBER .

    EQ              reduce using rule 37 (valeur -> NUMBER .)
    NEQ             reduce using rule 37 (valeur -> NUMBER .)
    LT              reduce using rule 37 (valeur -> NUMBER .)
    GT              reduce using rule 37 (valeur -> NUMBER .)
    LE              reduce using rule 37 (valeur -> NUMBER .)
    GE              reduce using rule 37 (valeur -> NUMBER .)
    RPAREN          reduce using rule 37 (valeur -> NUMBER .)
    SEMICOLON       reduce using rule 37 (valeur -> NUMBER .)


state 54

    (38) valeur -> IDENTIFIER .

    EQ              reduce using rule 38 (valeur -> IDENTIFIER .)
    NEQ             reduce using rule 38 (valeur -> IDENTIFIER .)
    LT              reduce using rule 38 (valeur -> IDENTIFIER .)
    GT              reduce using rule 38 (valeur -> IDENTIFIER .)
    LE              reduce using rule 38 (valeur -> IDENTIFIER .)
    GE              reduce using rule 38 (valeur -> IDENTIFIER .)
    RPAREN          reduce using rule 38 (valeur -> IDENTIFIER .)
    SEMICOLON       reduce using rule 38 (valeur -> IDENTIFIER .)


state 55

    (39) valeur -> STRING .

    EQ              reduce using rule 39 (valeur -> STRING .)
    NEQ             reduce using rule 39 (valeur -> STRING .)
    LT              reduce using rule 39 (valeur -> STRING .)
    GT              reduce using rule 39 (valeur -> STRING .)
    LE              reduce using rule 39 (valeur -> STRING .)
    GE              reduce using rule 39 (valeur -> STRING .)
    RPAREN          reduce using rule 39 (valeur -> STRING .)
    SEMICOLON       reduce using rule 39 (valeur -> STRING .)


state 56

    (54) boucle -> WHILE LPAREN expression_logique . RPAREN bloc

    RPAREN          shift and go to state 81


state 57

    (55) boucle -> FOR LPAREN assignation . SEMICOLON expression_logique SEMICOLON modification RPAREN bloc

    SEMICOLON       shift and go to state 82


state 58

    (41) bloc -> LBRACE programme RBRACE .

    DRAW            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    MOVE            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    ROTATE          reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    COLOR           reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    VARIABLE        reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    IDENTIFIER      reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    IF              reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    WHILE           reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    FOR             reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    LBRACE          reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    $end            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    RBRACE          reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    ELSE            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)


state 59

    (12) dessin -> DRAW forme LPAREN parametres . RPAREN
    (18) parametres -> parametres . COMMA arg

    RPAREN          shift and go to state 83
    COMMA           shift and go to state 84


state 60

    (19) parametres -> arg .

    RPAREN          reduce using rule 19 (parametres -> arg .)
    COMMA           reduce using rule 19 (parametres -> arg .)


state 61

    (29) expression_arithmetic -> LPAREN expression_arithmetic . RPAREN
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

    RPAREN          shift and go to state 85
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68


state 62

    (30) expression_arithmetic -> NUMBER .

    RPAREN          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    PLUS            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    MINUS           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    TIMES           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    DIVIDE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    COMMA           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    DRAW            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    MOVE            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    ROTATE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    COLOR           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    VARIABLE        reduce using rule 30 (expression_arithmetic -> NUMBER .)
    IDENTIFIER      reduce using rule 30 (expression_arithmetic -> NUMBER .)
    IF              reduce using rule 30 (expression_arithmetic -> NUMBER .)
    WHILE           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    FOR             reduce using rule 30 (expression_arithmetic -> NUMBER .)
    LBRACE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    $end            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    RBRACE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    SEMICOLON       reduce using rule 30 (expression_arithmetic -> NUMBER .)


state 63

    (31) expression_arithmetic -> IDENTIFIER .

    RPAREN          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    PLUS            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    MINUS           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    TIMES           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    DIVIDE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    COMMA           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    DRAW            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    MOVE            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    ROTATE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    COLOR           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    VARIABLE        reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    IF              reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    WHILE           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    FOR             reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    LBRACE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    $end            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    RBRACE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    SEMICOLON       reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)


state 64

    (32) deplacement -> MOVE LPAREN arg COMMA . arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    arg                            shift and go to state 86
    expression_arithmetic          shift and go to state 45

state 65

    (25) expression_arithmetic -> expression_arithmetic PLUS . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 62
    IDENTIFIER      shift and go to state 63

    expression_arithmetic          shift and go to state 87

state 66

    (26) expression_arithmetic -> expression_arithmetic MINUS . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 62
    IDENTIFIER      shift and go to state 63

    expression_arithmetic          shift and go to state 88

state 67

    (27) expression_arithmetic -> expression_arithmetic TIMES . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 62
    IDENTIFIER      shift and go to state 63

    expression_arithmetic          shift and go to state 89

state 68

    (28) expression_arithmetic -> expression_arithmetic DIVIDE . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 62
    IDENTIFIER      shift and go to state 63

    expression_arithmetic          shift and go to state 90

state 69

    (33) rotation -> ROTATE LPAREN arg RPAREN .

    DRAW            reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    MOVE            reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    ROTATE          reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    COLOR           reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    VARIABLE        reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    IDENTIFIER      reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    IF              reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    WHILE           reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    FOR             reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    LBRACE          reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    $end            reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    RBRACE          reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)


state 70

    (34) couleur -> COLOR LPAREN arg RPAREN .

    DRAW            reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    MOVE            reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    ROTATE          reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    COLOR           reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    VARIABLE        reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    IDENTIFIER      reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    IF              reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    WHILE           reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    FOR             reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    LBRACE          reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    $end            reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    RBRACE          reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)


state 71

    (35) assignation -> VARIABLE IDENTIFIER EQUALS arg .

    DRAW            reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    MOVE            reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    ROTATE          reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    COLOR           reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    VARIABLE        reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    IDENTIFIER      reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    IF              reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    WHILE           reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    FOR             reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    LBRACE          reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    $end            reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    RBRACE          reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    SEMICOLON       reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)


state 72

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN . bloc ELSE bloc
    (43) conditionnelle -> IF LPAREN expression_logique RPAREN . bloc
    (41) bloc -> . LBRACE programme RBRACE

    LBRACE          shift and go to state 21

    bloc                           shift and go to state 91

state 73

    (44) expression_logique -> valeur operateur_comparaison . valeur
    (45) expression_logique -> valeur operateur_comparaison . BOOLEAN
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    BOOLEAN         shift and go to state 93
    NUMBER          shift and go to state 53
    IDENTIFIER      shift and go to state 54
    STRING          shift and go to state 55

    valeur                         shift and go to state 92

state 74

    (48) operateur_comparaison -> EQ .

    BOOLEAN         reduce using rule 48 (operateur_comparaison -> EQ .)
    NUMBER          reduce using rule 48 (operateur_comparaison -> EQ .)
    IDENTIFIER      reduce using rule 48 (operateur_comparaison -> EQ .)
    STRING          reduce using rule 48 (operateur_comparaison -> EQ .)


state 75

    (49) operateur_comparaison -> NEQ .

    BOOLEAN         reduce using rule 49 (operateur_comparaison -> NEQ .)
    NUMBER          reduce using rule 49 (operateur_comparaison -> NEQ .)
    IDENTIFIER      reduce using rule 49 (operateur_comparaison -> NEQ .)
    STRING          reduce using rule 49 (operateur_comparaison -> NEQ .)


state 76

    (50) operateur_comparaison -> LT .

    BOOLEAN         reduce using rule 50 (operateur_comparaison -> LT .)
    NUMBER          reduce using rule 50 (operateur_comparaison -> LT .)
    IDENTIFIER      reduce using rule 50 (operateur_comparaison -> LT .)
    STRING          reduce using rule 50 (operateur_comparaison -> LT .)


state 77

    (51) operateur_comparaison -> GT .

    BOOLEAN         reduce using rule 51 (operateur_comparaison -> GT .)
    NUMBER          reduce using rule 51 (operateur_comparaison -> GT .)
    IDENTIFIER      reduce using rule 51 (operateur_comparaison -> GT .)
    STRING          reduce using rule 51 (operateur_comparaison -> GT .)


state 78

    (52) operateur_comparaison -> LE .

    BOOLEAN         reduce using rule 52 (operateur_comparaison -> LE .)
    NUMBER          reduce using rule 52 (operateur_comparaison -> LE .)
    IDENTIFIER      reduce using rule 52 (operateur_comparaison -> LE .)
    STRING          reduce using rule 52 (operateur_comparaison -> LE .)


state 79

    (53) operateur_comparaison -> GE .

    BOOLEAN         reduce using rule 53 (operateur_comparaison -> GE .)
    NUMBER          reduce using rule 53 (operateur_comparaison -> GE .)
    IDENTIFIER      reduce using rule 53 (operateur_comparaison -> GE .)
    STRING          reduce using rule 53 (operateur_comparaison -> GE .)


state 80

    (46) expression_logique -> BOOLEAN operateur_comparaison . valeur
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    NUMBER          shift and go to state 53
    IDENTIFIER      shift and go to state 54
    STRING          shift and go to state 55
    BOOLEAN         shift and go to state 94

    valeur                         shift and go to state 95

state 81

    (54) boucle -> WHILE LPAREN expression_logique RPAREN . bloc
    (41) bloc -> . LBRACE programme RBRACE

    LBRACE          shift and go to state 21

    bloc                           shift and go to state 96

state 82

    (55) boucle -> FOR LPAREN assignation SEMICOLON . expression_logique SEMICOLON modification RPAREN bloc
    (44) expression_logique -> . valeur operateur_comparaison valeur
    (45) expression_logique -> . valeur operateur_comparaison BOOLEAN
    (46) expression_logique -> . BOOLEAN operateur_comparaison valeur
    (47) expression_logique -> . BOOLEAN
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    BOOLEAN         shift and go to state 52
    NUMBER          shift and go to state 53
    IDENTIFIER      shift and go to state 54
    STRING          shift and go to state 55

    expression_logique             shift and go to state 97
    valeur                         shift and go to state 51

state 83

    (12) dessin -> DRAW forme LPAREN parametres RPAREN .

    DRAW            reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    MOVE            reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    ROTATE          reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    COLOR           reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    VARIABLE        reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    IDENTIFIER      reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    IF              reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    WHILE           reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    FOR             reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    LBRACE          reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    $end            reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    RBRACE          reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)


state 84

    (18) parametres -> parametres COMMA . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 41
    IDENTIFIER      shift and go to state 42
    STRING          shift and go to state 43
    BOOLEAN         shift and go to state 44
    LPAREN          shift and go to state 39

    arg                            shift and go to state 98
    expression_arithmetic          shift and go to state 45

state 85

    (29) expression_arithmetic -> LPAREN expression_arithmetic RPAREN .

    PLUS            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    MINUS           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    TIMES           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    DIVIDE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    COMMA           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    RPAREN          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    DRAW            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    MOVE            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    ROTATE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    COLOR           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    VARIABLE        reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    IF              reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    WHILE           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    FOR             reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    LBRACE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    $end            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    RBRACE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    SEMICOLON       reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)


state 86

    (32) deplacement -> MOVE LPAREN arg COMMA arg . RPAREN

    RPAREN          shift and go to state 99


state 87

    (25) expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    RPAREN          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    DRAW            reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    MOVE            reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    ROTATE          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    COLOR           reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    VARIABLE        reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    IDENTIFIER      reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    IF              reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    WHILE           reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    FOR             reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    LBRACE          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    $end            reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    RBRACE          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    SEMICOLON       reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]


state 88

    (26) expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    RPAREN          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    DRAW            reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    MOVE            reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    ROTATE          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    COLOR           reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    VARIABLE        reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    IDENTIFIER      reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    IF              reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    WHILE           reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    FOR             reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    LBRACE          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    $end            reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    RBRACE          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    SEMICOLON       reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]


state 89

    (27) expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    RPAREN          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    DRAW            reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    MOVE            reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    ROTATE          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    COLOR           reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    VARIABLE        reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    IDENTIFIER      reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    IF              reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    WHILE           reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    FOR             reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    LBRACE          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    $end            reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    RBRACE          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    SEMICOLON       reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]


state 90

    (28) expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    RPAREN          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    DRAW            reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    MOVE            reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    ROTATE          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    COLOR           reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    VARIABLE        reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    IDENTIFIER      reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    IF              reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    WHILE           reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    FOR             reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    LBRACE          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    $end            reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    RBRACE          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    SEMICOLON       reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]


state 91

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN bloc . ELSE bloc
    (43) conditionnelle -> IF LPAREN expression_logique RPAREN bloc .

    ELSE            shift and go to state 100
    DRAW            reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    MOVE            reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    ROTATE          reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    COLOR           reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    VARIABLE        reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    IDENTIFIER      reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    IF              reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    WHILE           reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    FOR             reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    LBRACE          reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    $end            reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    RBRACE          reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)


state 92

    (44) expression_logique -> valeur operateur_comparaison valeur .

    RPAREN          reduce using rule 44 (expression_logique -> valeur operateur_comparaison valeur .)
    SEMICOLON       reduce using rule 44 (expression_logique -> valeur operateur_comparaison valeur .)


state 93

    (45) expression_logique -> valeur operateur_comparaison BOOLEAN .
    (40) valeur -> BOOLEAN .

  ! reduce/reduce conflict for RPAREN resolved using rule 40 (valeur -> BOOLEAN .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 40 (valeur -> BOOLEAN .)
    RPAREN          reduce using rule 40 (valeur -> BOOLEAN .)
    SEMICOLON       reduce using rule 40 (valeur -> BOOLEAN .)

  ! RPAREN          [ reduce using rule 45 (expression_logique -> valeur operateur_comparaison BOOLEAN .) ]
  ! SEMICOLON       [ reduce using rule 45 (expression_logique -> valeur operateur_comparaison BOOLEAN .) ]


state 94

    (40) valeur -> BOOLEAN .

    RPAREN          reduce using rule 40 (valeur -> BOOLEAN .)
    SEMICOLON       reduce using rule 40 (valeur -> BOOLEAN .)


state 95

    (46) expression_logique -> BOOLEAN operateur_comparaison valeur .

    RPAREN          reduce using rule 46 (expression_logique -> BOOLEAN operateur_comparaison valeur .)
    SEMICOLON       reduce using rule 46 (expression_logique -> BOOLEAN operateur_comparaison valeur .)


state 96

    (54) boucle -> WHILE LPAREN expression_logique RPAREN bloc .

    DRAW            reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    MOVE            reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    ROTATE          reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    COLOR           reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    VARIABLE        reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    IDENTIFIER      reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    IF              reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    WHILE           reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    FOR             reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    LBRACE          reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    $end            reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)
    RBRACE          reduce using rule 54 (boucle -> WHILE LPAREN expression_logique RPAREN bloc .)


state 97

    (55) boucle -> FOR LPAREN assignation SEMICOLON expression_logique . SEMICOLON modification RPAREN bloc

    SEMICOLON       shift and go to state 101


state 98

    (18) parametres -> parametres COMMA arg .

    RPAREN          reduce using rule 18 (parametres -> parametres COMMA arg .)
    COMMA           reduce using rule 18 (parametres -> parametres COMMA arg .)


state 99

    (32) deplacement -> MOVE LPAREN arg COMMA arg RPAREN .

    DRAW            reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    MOVE            reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    ROTATE          reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    COLOR           reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    VARIABLE        reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    IDENTIFIER      reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    IF              reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    WHILE           reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    FOR             reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    LBRACE          reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    $end            reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    RBRACE          reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)


state 100

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE . bloc
    (41) bloc -> . LBRACE programme RBRACE

    LBRACE          shift and go to state 21

    bloc                           shift and go to state 102

state 101

    (55) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON . modification RPAREN bloc
    (36) modification -> . IDENTIFIER EQUALS arg

    IDENTIFIER      shift and go to state 17

    modification                   shift and go to state 103

state 102

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .

    DRAW            reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    MOVE            reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    ROTATE          reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    COLOR           reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    VARIABLE        reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    IDENTIFIER      reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    IF              reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    WHILE           reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    FOR             reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    LBRACE          reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    $end            reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    RBRACE          reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)


state 103

    (55) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification . RPAREN bloc

    RPAREN          shift and go to state 104


state 104

    (55) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN . bloc
    (41) bloc -> . LBRACE programme RBRACE

    LBRACE          shift and go to state 21

    bloc                           shift and go to state 105

state 105

    (55) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .

    DRAW            reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    MOVE            reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    ROTATE          reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    COLOR           reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    VARIABLE        reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    IDENTIFIER      reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    IF              reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    WHILE           reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    FOR             reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    LBRACE          reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    $end            reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    RBRACE          reduce using rule 55 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ in state 52 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 52 resolved as shift
WARNING: shift/reduce conflict for LT in state 52 resolved as shift
WARNING: shift/reduce conflict for GT in state 52 resolved as shift
WARNING: shift/reduce conflict for LE in state 52 resolved as shift
WARNING: shift/reduce conflict for GE in state 52 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 87 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 87 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 87 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 87 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 88 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 89 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 89 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 89 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 89 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 90 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 90 resolved as shift
WARNING: reduce/reduce conflict in state 41 resolved using rule (arg -> NUMBER)
WARNING: rejected rule (expression_arithmetic -> NUMBER) in state 41
WARNING: reduce/reduce conflict in state 42 resolved using rule (arg -> IDENTIFIER)
WARNING: rejected rule (expression_arithmetic -> IDENTIFIER) in state 42
WARNING: reduce/reduce conflict in state 93 resolved using rule (valeur -> BOOLEAN)
WARNING: rejected rule (expression_logique -> valeur operateur_comparaison BOOLEAN) in state 93
WARNING: Rule (expression_logique -> valeur operateur_comparaison BOOLEAN) is never reduced
