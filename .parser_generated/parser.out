Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANIMATE
    COLON
    CURSOR
    DO
    LBRACKET
    NOT
    OR
    RBRACKET
    WHILE

Grammar

Rule 0     S' -> programme
Rule 1     programme -> instruction
Rule 2     programme -> programme instruction
Rule 3     instruction -> dessin
Rule 4     instruction -> deplacement
Rule 5     instruction -> rotation
Rule 6     instruction -> couleur
Rule 7     instruction -> assignation
Rule 8     instruction -> modification
Rule 9     instruction -> conditionnelle
Rule 10    instruction -> boucle
Rule 11    instruction -> bloc
Rule 12    dessin -> DRAW forme LPAREN parametres RPAREN
Rule 13    forme -> LINE
Rule 14    forme -> CIRCLE
Rule 15    forme -> SQUARE
Rule 16    forme -> ARC
Rule 17    forme -> POINT
Rule 18    parametres -> parametres COMMA arg
Rule 19    parametres -> arg
Rule 20    arg -> NUMBER
Rule 21    arg -> IDENTIFIER
Rule 22    arg -> STRING
Rule 23    arg -> BOOLEAN
Rule 24    arg -> expression_arithmetic
Rule 25    expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic
Rule 26    expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic
Rule 27    expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic
Rule 28    expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic
Rule 29    expression_arithmetic -> LPAREN expression_arithmetic RPAREN
Rule 30    expression_arithmetic -> NUMBER
Rule 31    expression_arithmetic -> IDENTIFIER
Rule 32    deplacement -> MOVE LPAREN arg COMMA arg RPAREN
Rule 33    rotation -> ROTATE LPAREN arg RPAREN
Rule 34    couleur -> COLOR LPAREN arg RPAREN
Rule 35    assignation -> VARIABLE IDENTIFIER EQUALS arg
Rule 36    modification -> IDENTIFIER EQUALS arg
Rule 37    valeur -> NUMBER
Rule 38    valeur -> IDENTIFIER
Rule 39    valeur -> STRING
Rule 40    valeur -> BOOLEAN
Rule 41    bloc -> LBRACE programme RBRACE
Rule 42    conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc
Rule 43    conditionnelle -> IF LPAREN expression_logique RPAREN bloc
Rule 44    expression_logique -> valeur operateur_comparaison valeur
Rule 45    expression_logique -> valeur operateur_comparaison BOOLEAN
Rule 46    expression_logique -> BOOLEAN operateur_comparaison valeur
Rule 47    expression_logique -> BOOLEAN
Rule 48    operateur_comparaison -> EQ
Rule 49    operateur_comparaison -> NEQ
Rule 50    operateur_comparaison -> LT
Rule 51    operateur_comparaison -> GT
Rule 52    operateur_comparaison -> LE
Rule 53    operateur_comparaison -> GE
Rule 54    boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc

Terminals, with rules where they appear

AND                  : 
ANIMATE              : 
ARC                  : 16
BOOLEAN              : 23 40 45 46 47
CIRCLE               : 14
COLON                : 
COLOR                : 34
COMMA                : 18 32
CURSOR               : 
DIVIDE               : 28
DO                   : 
DRAW                 : 12
ELSE                 : 42
EQ                   : 48
EQUALS               : 35 36
FOR                  : 54
GE                   : 53
GT                   : 51
IDENTIFIER           : 21 31 35 36 38
IF                   : 42 43
LBRACE               : 41
LBRACKET             : 
LE                   : 52
LINE                 : 13
LPAREN               : 12 29 32 33 34 42 43 54
LT                   : 50
MINUS                : 26
MOVE                 : 32
NEQ                  : 49
NOT                  : 
NUMBER               : 20 30 37
OR                   : 
PLUS                 : 25
POINT                : 17
RBRACE               : 41
RBRACKET             : 
ROTATE               : 33
RPAREN               : 12 29 32 33 34 42 43 54
SEMICOLON            : 54 54
SQUARE               : 15
STRING               : 22 39
TIMES                : 27
VARIABLE             : 35
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arg                  : 18 19 32 32 33 34 35 36
assignation          : 7 54
bloc                 : 11 42 42 43 54
boucle               : 10
conditionnelle       : 9
couleur              : 6
deplacement          : 4
dessin               : 3
expression_arithmetic : 24 25 25 26 26 27 27 28 28 29
expression_logique   : 42 43 54
forme                : 12
instruction          : 1 2
modification         : 8 54
operateur_comparaison : 44 45 46
parametres           : 12 18
programme            : 2 41 0
rotation             : 5
valeur               : 44 44 45 46

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . instruction
    (2) programme -> . programme instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    FOR             shift and go to state 19
    LBRACE          shift and go to state 20

    programme                      shift and go to state 1
    instruction                    shift and go to state 2
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 1

    (0) S' -> programme .
    (2) programme -> programme . instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    FOR             shift and go to state 19
    LBRACE          shift and go to state 20

    instruction                    shift and go to state 21
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 2

    (1) programme -> instruction .

    DRAW            reduce using rule 1 (programme -> instruction .)
    MOVE            reduce using rule 1 (programme -> instruction .)
    ROTATE          reduce using rule 1 (programme -> instruction .)
    COLOR           reduce using rule 1 (programme -> instruction .)
    VARIABLE        reduce using rule 1 (programme -> instruction .)
    IDENTIFIER      reduce using rule 1 (programme -> instruction .)
    IF              reduce using rule 1 (programme -> instruction .)
    FOR             reduce using rule 1 (programme -> instruction .)
    LBRACE          reduce using rule 1 (programme -> instruction .)
    $end            reduce using rule 1 (programme -> instruction .)
    RBRACE          reduce using rule 1 (programme -> instruction .)


state 3

    (3) instruction -> dessin .

    DRAW            reduce using rule 3 (instruction -> dessin .)
    MOVE            reduce using rule 3 (instruction -> dessin .)
    ROTATE          reduce using rule 3 (instruction -> dessin .)
    COLOR           reduce using rule 3 (instruction -> dessin .)
    VARIABLE        reduce using rule 3 (instruction -> dessin .)
    IDENTIFIER      reduce using rule 3 (instruction -> dessin .)
    IF              reduce using rule 3 (instruction -> dessin .)
    FOR             reduce using rule 3 (instruction -> dessin .)
    LBRACE          reduce using rule 3 (instruction -> dessin .)
    $end            reduce using rule 3 (instruction -> dessin .)
    RBRACE          reduce using rule 3 (instruction -> dessin .)


state 4

    (4) instruction -> deplacement .

    DRAW            reduce using rule 4 (instruction -> deplacement .)
    MOVE            reduce using rule 4 (instruction -> deplacement .)
    ROTATE          reduce using rule 4 (instruction -> deplacement .)
    COLOR           reduce using rule 4 (instruction -> deplacement .)
    VARIABLE        reduce using rule 4 (instruction -> deplacement .)
    IDENTIFIER      reduce using rule 4 (instruction -> deplacement .)
    IF              reduce using rule 4 (instruction -> deplacement .)
    FOR             reduce using rule 4 (instruction -> deplacement .)
    LBRACE          reduce using rule 4 (instruction -> deplacement .)
    $end            reduce using rule 4 (instruction -> deplacement .)
    RBRACE          reduce using rule 4 (instruction -> deplacement .)


state 5

    (5) instruction -> rotation .

    DRAW            reduce using rule 5 (instruction -> rotation .)
    MOVE            reduce using rule 5 (instruction -> rotation .)
    ROTATE          reduce using rule 5 (instruction -> rotation .)
    COLOR           reduce using rule 5 (instruction -> rotation .)
    VARIABLE        reduce using rule 5 (instruction -> rotation .)
    IDENTIFIER      reduce using rule 5 (instruction -> rotation .)
    IF              reduce using rule 5 (instruction -> rotation .)
    FOR             reduce using rule 5 (instruction -> rotation .)
    LBRACE          reduce using rule 5 (instruction -> rotation .)
    $end            reduce using rule 5 (instruction -> rotation .)
    RBRACE          reduce using rule 5 (instruction -> rotation .)


state 6

    (6) instruction -> couleur .

    DRAW            reduce using rule 6 (instruction -> couleur .)
    MOVE            reduce using rule 6 (instruction -> couleur .)
    ROTATE          reduce using rule 6 (instruction -> couleur .)
    COLOR           reduce using rule 6 (instruction -> couleur .)
    VARIABLE        reduce using rule 6 (instruction -> couleur .)
    IDENTIFIER      reduce using rule 6 (instruction -> couleur .)
    IF              reduce using rule 6 (instruction -> couleur .)
    FOR             reduce using rule 6 (instruction -> couleur .)
    LBRACE          reduce using rule 6 (instruction -> couleur .)
    $end            reduce using rule 6 (instruction -> couleur .)
    RBRACE          reduce using rule 6 (instruction -> couleur .)


state 7

    (7) instruction -> assignation .

    DRAW            reduce using rule 7 (instruction -> assignation .)
    MOVE            reduce using rule 7 (instruction -> assignation .)
    ROTATE          reduce using rule 7 (instruction -> assignation .)
    COLOR           reduce using rule 7 (instruction -> assignation .)
    VARIABLE        reduce using rule 7 (instruction -> assignation .)
    IDENTIFIER      reduce using rule 7 (instruction -> assignation .)
    IF              reduce using rule 7 (instruction -> assignation .)
    FOR             reduce using rule 7 (instruction -> assignation .)
    LBRACE          reduce using rule 7 (instruction -> assignation .)
    $end            reduce using rule 7 (instruction -> assignation .)
    RBRACE          reduce using rule 7 (instruction -> assignation .)


state 8

    (8) instruction -> modification .

    DRAW            reduce using rule 8 (instruction -> modification .)
    MOVE            reduce using rule 8 (instruction -> modification .)
    ROTATE          reduce using rule 8 (instruction -> modification .)
    COLOR           reduce using rule 8 (instruction -> modification .)
    VARIABLE        reduce using rule 8 (instruction -> modification .)
    IDENTIFIER      reduce using rule 8 (instruction -> modification .)
    IF              reduce using rule 8 (instruction -> modification .)
    FOR             reduce using rule 8 (instruction -> modification .)
    LBRACE          reduce using rule 8 (instruction -> modification .)
    $end            reduce using rule 8 (instruction -> modification .)
    RBRACE          reduce using rule 8 (instruction -> modification .)


state 9

    (9) instruction -> conditionnelle .

    DRAW            reduce using rule 9 (instruction -> conditionnelle .)
    MOVE            reduce using rule 9 (instruction -> conditionnelle .)
    ROTATE          reduce using rule 9 (instruction -> conditionnelle .)
    COLOR           reduce using rule 9 (instruction -> conditionnelle .)
    VARIABLE        reduce using rule 9 (instruction -> conditionnelle .)
    IDENTIFIER      reduce using rule 9 (instruction -> conditionnelle .)
    IF              reduce using rule 9 (instruction -> conditionnelle .)
    FOR             reduce using rule 9 (instruction -> conditionnelle .)
    LBRACE          reduce using rule 9 (instruction -> conditionnelle .)
    $end            reduce using rule 9 (instruction -> conditionnelle .)
    RBRACE          reduce using rule 9 (instruction -> conditionnelle .)


state 10

    (10) instruction -> boucle .

    DRAW            reduce using rule 10 (instruction -> boucle .)
    MOVE            reduce using rule 10 (instruction -> boucle .)
    ROTATE          reduce using rule 10 (instruction -> boucle .)
    COLOR           reduce using rule 10 (instruction -> boucle .)
    VARIABLE        reduce using rule 10 (instruction -> boucle .)
    IDENTIFIER      reduce using rule 10 (instruction -> boucle .)
    IF              reduce using rule 10 (instruction -> boucle .)
    FOR             reduce using rule 10 (instruction -> boucle .)
    LBRACE          reduce using rule 10 (instruction -> boucle .)
    $end            reduce using rule 10 (instruction -> boucle .)
    RBRACE          reduce using rule 10 (instruction -> boucle .)


state 11

    (11) instruction -> bloc .

    DRAW            reduce using rule 11 (instruction -> bloc .)
    MOVE            reduce using rule 11 (instruction -> bloc .)
    ROTATE          reduce using rule 11 (instruction -> bloc .)
    COLOR           reduce using rule 11 (instruction -> bloc .)
    VARIABLE        reduce using rule 11 (instruction -> bloc .)
    IDENTIFIER      reduce using rule 11 (instruction -> bloc .)
    IF              reduce using rule 11 (instruction -> bloc .)
    FOR             reduce using rule 11 (instruction -> bloc .)
    LBRACE          reduce using rule 11 (instruction -> bloc .)
    $end            reduce using rule 11 (instruction -> bloc .)
    RBRACE          reduce using rule 11 (instruction -> bloc .)


state 12

    (12) dessin -> DRAW . forme LPAREN parametres RPAREN
    (13) forme -> . LINE
    (14) forme -> . CIRCLE
    (15) forme -> . SQUARE
    (16) forme -> . ARC
    (17) forme -> . POINT

    LINE            shift and go to state 23
    CIRCLE          shift and go to state 24
    SQUARE          shift and go to state 25
    ARC             shift and go to state 26
    POINT           shift and go to state 27

    forme                          shift and go to state 22

state 13

    (32) deplacement -> MOVE . LPAREN arg COMMA arg RPAREN

    LPAREN          shift and go to state 28


state 14

    (33) rotation -> ROTATE . LPAREN arg RPAREN

    LPAREN          shift and go to state 29


state 15

    (34) couleur -> COLOR . LPAREN arg RPAREN

    LPAREN          shift and go to state 30


state 16

    (35) assignation -> VARIABLE . IDENTIFIER EQUALS arg

    IDENTIFIER      shift and go to state 31


state 17

    (36) modification -> IDENTIFIER . EQUALS arg

    EQUALS          shift and go to state 32


state 18

    (42) conditionnelle -> IF . LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> IF . LPAREN expression_logique RPAREN bloc

    LPAREN          shift and go to state 33


state 19

    (54) boucle -> FOR . LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc

    LPAREN          shift and go to state 34


state 20

    (41) bloc -> LBRACE . programme RBRACE
    (1) programme -> . instruction
    (2) programme -> . programme instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    FOR             shift and go to state 19
    LBRACE          shift and go to state 20

    programme                      shift and go to state 35
    instruction                    shift and go to state 2
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 21

    (2) programme -> programme instruction .

    DRAW            reduce using rule 2 (programme -> programme instruction .)
    MOVE            reduce using rule 2 (programme -> programme instruction .)
    ROTATE          reduce using rule 2 (programme -> programme instruction .)
    COLOR           reduce using rule 2 (programme -> programme instruction .)
    VARIABLE        reduce using rule 2 (programme -> programme instruction .)
    IDENTIFIER      reduce using rule 2 (programme -> programme instruction .)
    IF              reduce using rule 2 (programme -> programme instruction .)
    FOR             reduce using rule 2 (programme -> programme instruction .)
    LBRACE          reduce using rule 2 (programme -> programme instruction .)
    $end            reduce using rule 2 (programme -> programme instruction .)
    RBRACE          reduce using rule 2 (programme -> programme instruction .)


state 22

    (12) dessin -> DRAW forme . LPAREN parametres RPAREN

    LPAREN          shift and go to state 36


state 23

    (13) forme -> LINE .

    LPAREN          reduce using rule 13 (forme -> LINE .)


state 24

    (14) forme -> CIRCLE .

    LPAREN          reduce using rule 14 (forme -> CIRCLE .)


state 25

    (15) forme -> SQUARE .

    LPAREN          reduce using rule 15 (forme -> SQUARE .)


state 26

    (16) forme -> ARC .

    LPAREN          reduce using rule 16 (forme -> ARC .)


state 27

    (17) forme -> POINT .

    LPAREN          reduce using rule 17 (forme -> POINT .)


state 28

    (32) deplacement -> MOVE LPAREN . arg COMMA arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    arg                            shift and go to state 38
    expression_arithmetic          shift and go to state 43

state 29

    (33) rotation -> ROTATE LPAREN . arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    arg                            shift and go to state 44
    expression_arithmetic          shift and go to state 43

state 30

    (34) couleur -> COLOR LPAREN . arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    arg                            shift and go to state 45
    expression_arithmetic          shift and go to state 43

state 31

    (35) assignation -> VARIABLE IDENTIFIER . EQUALS arg

    EQUALS          shift and go to state 46


state 32

    (36) modification -> IDENTIFIER EQUALS . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    arg                            shift and go to state 47
    expression_arithmetic          shift and go to state 43

state 33

    (42) conditionnelle -> IF LPAREN . expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> IF LPAREN . expression_logique RPAREN bloc
    (44) expression_logique -> . valeur operateur_comparaison valeur
    (45) expression_logique -> . valeur operateur_comparaison BOOLEAN
    (46) expression_logique -> . BOOLEAN operateur_comparaison valeur
    (47) expression_logique -> . BOOLEAN
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    BOOLEAN         shift and go to state 50
    NUMBER          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    STRING          shift and go to state 53

    expression_logique             shift and go to state 48
    valeur                         shift and go to state 49

state 34

    (54) boucle -> FOR LPAREN . assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg

    VARIABLE        shift and go to state 16

    assignation                    shift and go to state 54

state 35

    (41) bloc -> LBRACE programme . RBRACE
    (2) programme -> programme . instruction
    (3) instruction -> . dessin
    (4) instruction -> . deplacement
    (5) instruction -> . rotation
    (6) instruction -> . couleur
    (7) instruction -> . assignation
    (8) instruction -> . modification
    (9) instruction -> . conditionnelle
    (10) instruction -> . boucle
    (11) instruction -> . bloc
    (12) dessin -> . DRAW forme LPAREN parametres RPAREN
    (32) deplacement -> . MOVE LPAREN arg COMMA arg RPAREN
    (33) rotation -> . ROTATE LPAREN arg RPAREN
    (34) couleur -> . COLOR LPAREN arg RPAREN
    (35) assignation -> . VARIABLE IDENTIFIER EQUALS arg
    (36) modification -> . IDENTIFIER EQUALS arg
    (42) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc ELSE bloc
    (43) conditionnelle -> . IF LPAREN expression_logique RPAREN bloc
    (54) boucle -> . FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc
    (41) bloc -> . LBRACE programme RBRACE

    RBRACE          shift and go to state 55
    DRAW            shift and go to state 12
    MOVE            shift and go to state 13
    ROTATE          shift and go to state 14
    COLOR           shift and go to state 15
    VARIABLE        shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    FOR             shift and go to state 19
    LBRACE          shift and go to state 20

    instruction                    shift and go to state 21
    dessin                         shift and go to state 3
    deplacement                    shift and go to state 4
    rotation                       shift and go to state 5
    couleur                        shift and go to state 6
    assignation                    shift and go to state 7
    modification                   shift and go to state 8
    conditionnelle                 shift and go to state 9
    boucle                         shift and go to state 10
    bloc                           shift and go to state 11

state 36

    (12) dessin -> DRAW forme LPAREN . parametres RPAREN
    (18) parametres -> . parametres COMMA arg
    (19) parametres -> . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    parametres                     shift and go to state 56
    arg                            shift and go to state 57
    expression_arithmetic          shift and go to state 43

state 37

    (29) expression_arithmetic -> LPAREN . expression_arithmetic RPAREN
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 37
    NUMBER          shift and go to state 59
    IDENTIFIER      shift and go to state 60

    expression_arithmetic          shift and go to state 58

state 38

    (32) deplacement -> MOVE LPAREN arg . COMMA arg RPAREN

    COMMA           shift and go to state 61


state 39

    (20) arg -> NUMBER .
    (30) expression_arithmetic -> NUMBER .

  ! reduce/reduce conflict for COMMA resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for DRAW resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for MOVE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for ROTATE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for COLOR resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for IF resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for FOR resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 20 (arg -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (arg -> NUMBER .)
    COMMA           reduce using rule 20 (arg -> NUMBER .)
    RPAREN          reduce using rule 20 (arg -> NUMBER .)
    DRAW            reduce using rule 20 (arg -> NUMBER .)
    MOVE            reduce using rule 20 (arg -> NUMBER .)
    ROTATE          reduce using rule 20 (arg -> NUMBER .)
    COLOR           reduce using rule 20 (arg -> NUMBER .)
    VARIABLE        reduce using rule 20 (arg -> NUMBER .)
    IDENTIFIER      reduce using rule 20 (arg -> NUMBER .)
    IF              reduce using rule 20 (arg -> NUMBER .)
    FOR             reduce using rule 20 (arg -> NUMBER .)
    LBRACE          reduce using rule 20 (arg -> NUMBER .)
    $end            reduce using rule 20 (arg -> NUMBER .)
    RBRACE          reduce using rule 20 (arg -> NUMBER .)
    SEMICOLON       reduce using rule 20 (arg -> NUMBER .)
    PLUS            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    MINUS           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    TIMES           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    DIVIDE          reduce using rule 30 (expression_arithmetic -> NUMBER .)

  ! COMMA           [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! DRAW            [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! MOVE            [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! ROTATE          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! COLOR           [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! VARIABLE        [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! IDENTIFIER      [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! IF              [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! FOR             [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! LBRACE          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! $end            [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! RBRACE          [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]
  ! SEMICOLON       [ reduce using rule 30 (expression_arithmetic -> NUMBER .) ]


state 40

    (21) arg -> IDENTIFIER .
    (31) expression_arithmetic -> IDENTIFIER .

  ! reduce/reduce conflict for COMMA resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for DRAW resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for MOVE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for ROTATE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for COLOR resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for FOR resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 21 (arg -> IDENTIFIER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (arg -> IDENTIFIER .)
    COMMA           reduce using rule 21 (arg -> IDENTIFIER .)
    RPAREN          reduce using rule 21 (arg -> IDENTIFIER .)
    DRAW            reduce using rule 21 (arg -> IDENTIFIER .)
    MOVE            reduce using rule 21 (arg -> IDENTIFIER .)
    ROTATE          reduce using rule 21 (arg -> IDENTIFIER .)
    COLOR           reduce using rule 21 (arg -> IDENTIFIER .)
    VARIABLE        reduce using rule 21 (arg -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 21 (arg -> IDENTIFIER .)
    IF              reduce using rule 21 (arg -> IDENTIFIER .)
    FOR             reduce using rule 21 (arg -> IDENTIFIER .)
    LBRACE          reduce using rule 21 (arg -> IDENTIFIER .)
    $end            reduce using rule 21 (arg -> IDENTIFIER .)
    RBRACE          reduce using rule 21 (arg -> IDENTIFIER .)
    SEMICOLON       reduce using rule 21 (arg -> IDENTIFIER .)
    PLUS            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    MINUS           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    TIMES           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    DIVIDE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)

  ! COMMA           [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! RPAREN          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! DRAW            [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! MOVE            [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! ROTATE          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! COLOR           [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! VARIABLE        [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! FOR             [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! $end            [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! RBRACE          [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]
  ! SEMICOLON       [ reduce using rule 31 (expression_arithmetic -> IDENTIFIER .) ]


state 41

    (22) arg -> STRING .

    COMMA           reduce using rule 22 (arg -> STRING .)
    RPAREN          reduce using rule 22 (arg -> STRING .)
    DRAW            reduce using rule 22 (arg -> STRING .)
    MOVE            reduce using rule 22 (arg -> STRING .)
    ROTATE          reduce using rule 22 (arg -> STRING .)
    COLOR           reduce using rule 22 (arg -> STRING .)
    VARIABLE        reduce using rule 22 (arg -> STRING .)
    IDENTIFIER      reduce using rule 22 (arg -> STRING .)
    IF              reduce using rule 22 (arg -> STRING .)
    FOR             reduce using rule 22 (arg -> STRING .)
    LBRACE          reduce using rule 22 (arg -> STRING .)
    $end            reduce using rule 22 (arg -> STRING .)
    RBRACE          reduce using rule 22 (arg -> STRING .)
    SEMICOLON       reduce using rule 22 (arg -> STRING .)


state 42

    (23) arg -> BOOLEAN .

    COMMA           reduce using rule 23 (arg -> BOOLEAN .)
    RPAREN          reduce using rule 23 (arg -> BOOLEAN .)
    DRAW            reduce using rule 23 (arg -> BOOLEAN .)
    MOVE            reduce using rule 23 (arg -> BOOLEAN .)
    ROTATE          reduce using rule 23 (arg -> BOOLEAN .)
    COLOR           reduce using rule 23 (arg -> BOOLEAN .)
    VARIABLE        reduce using rule 23 (arg -> BOOLEAN .)
    IDENTIFIER      reduce using rule 23 (arg -> BOOLEAN .)
    IF              reduce using rule 23 (arg -> BOOLEAN .)
    FOR             reduce using rule 23 (arg -> BOOLEAN .)
    LBRACE          reduce using rule 23 (arg -> BOOLEAN .)
    $end            reduce using rule 23 (arg -> BOOLEAN .)
    RBRACE          reduce using rule 23 (arg -> BOOLEAN .)
    SEMICOLON       reduce using rule 23 (arg -> BOOLEAN .)


state 43

    (24) arg -> expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

    COMMA           reduce using rule 24 (arg -> expression_arithmetic .)
    RPAREN          reduce using rule 24 (arg -> expression_arithmetic .)
    DRAW            reduce using rule 24 (arg -> expression_arithmetic .)
    MOVE            reduce using rule 24 (arg -> expression_arithmetic .)
    ROTATE          reduce using rule 24 (arg -> expression_arithmetic .)
    COLOR           reduce using rule 24 (arg -> expression_arithmetic .)
    VARIABLE        reduce using rule 24 (arg -> expression_arithmetic .)
    IDENTIFIER      reduce using rule 24 (arg -> expression_arithmetic .)
    IF              reduce using rule 24 (arg -> expression_arithmetic .)
    FOR             reduce using rule 24 (arg -> expression_arithmetic .)
    LBRACE          reduce using rule 24 (arg -> expression_arithmetic .)
    $end            reduce using rule 24 (arg -> expression_arithmetic .)
    RBRACE          reduce using rule 24 (arg -> expression_arithmetic .)
    SEMICOLON       reduce using rule 24 (arg -> expression_arithmetic .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65


state 44

    (33) rotation -> ROTATE LPAREN arg . RPAREN

    RPAREN          shift and go to state 66


state 45

    (34) couleur -> COLOR LPAREN arg . RPAREN

    RPAREN          shift and go to state 67


state 46

    (35) assignation -> VARIABLE IDENTIFIER EQUALS . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    arg                            shift and go to state 68
    expression_arithmetic          shift and go to state 43

state 47

    (36) modification -> IDENTIFIER EQUALS arg .

    DRAW            reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    MOVE            reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    ROTATE          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    COLOR           reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    VARIABLE        reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    IDENTIFIER      reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    IF              reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    FOR             reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    LBRACE          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    $end            reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    RBRACE          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)
    RPAREN          reduce using rule 36 (modification -> IDENTIFIER EQUALS arg .)


state 48

    (42) conditionnelle -> IF LPAREN expression_logique . RPAREN bloc ELSE bloc
    (43) conditionnelle -> IF LPAREN expression_logique . RPAREN bloc

    RPAREN          shift and go to state 69


state 49

    (44) expression_logique -> valeur . operateur_comparaison valeur
    (45) expression_logique -> valeur . operateur_comparaison BOOLEAN
    (48) operateur_comparaison -> . EQ
    (49) operateur_comparaison -> . NEQ
    (50) operateur_comparaison -> . LT
    (51) operateur_comparaison -> . GT
    (52) operateur_comparaison -> . LE
    (53) operateur_comparaison -> . GE

    EQ              shift and go to state 71
    NEQ             shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76

    operateur_comparaison          shift and go to state 70

state 50

    (46) expression_logique -> BOOLEAN . operateur_comparaison valeur
    (47) expression_logique -> BOOLEAN .
    (40) valeur -> BOOLEAN .
    (48) operateur_comparaison -> . EQ
    (49) operateur_comparaison -> . NEQ
    (50) operateur_comparaison -> . LT
    (51) operateur_comparaison -> . GT
    (52) operateur_comparaison -> . LE
    (53) operateur_comparaison -> . GE

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RPAREN          reduce using rule 47 (expression_logique -> BOOLEAN .)
    SEMICOLON       reduce using rule 47 (expression_logique -> BOOLEAN .)
    EQ              shift and go to state 71
    NEQ             shift and go to state 72
    LT              shift and go to state 73
    GT              shift and go to state 74
    LE              shift and go to state 75
    GE              shift and go to state 76

  ! EQ              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! NEQ             [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! LT              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! GT              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! LE              [ reduce using rule 40 (valeur -> BOOLEAN .) ]
  ! GE              [ reduce using rule 40 (valeur -> BOOLEAN .) ]

    operateur_comparaison          shift and go to state 77

state 51

    (37) valeur -> NUMBER .

    EQ              reduce using rule 37 (valeur -> NUMBER .)
    NEQ             reduce using rule 37 (valeur -> NUMBER .)
    LT              reduce using rule 37 (valeur -> NUMBER .)
    GT              reduce using rule 37 (valeur -> NUMBER .)
    LE              reduce using rule 37 (valeur -> NUMBER .)
    GE              reduce using rule 37 (valeur -> NUMBER .)
    RPAREN          reduce using rule 37 (valeur -> NUMBER .)
    SEMICOLON       reduce using rule 37 (valeur -> NUMBER .)


state 52

    (38) valeur -> IDENTIFIER .

    EQ              reduce using rule 38 (valeur -> IDENTIFIER .)
    NEQ             reduce using rule 38 (valeur -> IDENTIFIER .)
    LT              reduce using rule 38 (valeur -> IDENTIFIER .)
    GT              reduce using rule 38 (valeur -> IDENTIFIER .)
    LE              reduce using rule 38 (valeur -> IDENTIFIER .)
    GE              reduce using rule 38 (valeur -> IDENTIFIER .)
    RPAREN          reduce using rule 38 (valeur -> IDENTIFIER .)
    SEMICOLON       reduce using rule 38 (valeur -> IDENTIFIER .)


state 53

    (39) valeur -> STRING .

    EQ              reduce using rule 39 (valeur -> STRING .)
    NEQ             reduce using rule 39 (valeur -> STRING .)
    LT              reduce using rule 39 (valeur -> STRING .)
    GT              reduce using rule 39 (valeur -> STRING .)
    LE              reduce using rule 39 (valeur -> STRING .)
    GE              reduce using rule 39 (valeur -> STRING .)
    RPAREN          reduce using rule 39 (valeur -> STRING .)
    SEMICOLON       reduce using rule 39 (valeur -> STRING .)


state 54

    (54) boucle -> FOR LPAREN assignation . SEMICOLON expression_logique SEMICOLON modification RPAREN bloc

    SEMICOLON       shift and go to state 78


state 55

    (41) bloc -> LBRACE programme RBRACE .

    DRAW            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    MOVE            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    ROTATE          reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    COLOR           reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    VARIABLE        reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    IDENTIFIER      reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    IF              reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    FOR             reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    LBRACE          reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    $end            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    RBRACE          reduce using rule 41 (bloc -> LBRACE programme RBRACE .)
    ELSE            reduce using rule 41 (bloc -> LBRACE programme RBRACE .)


state 56

    (12) dessin -> DRAW forme LPAREN parametres . RPAREN
    (18) parametres -> parametres . COMMA arg

    RPAREN          shift and go to state 79
    COMMA           shift and go to state 80


state 57

    (19) parametres -> arg .

    RPAREN          reduce using rule 19 (parametres -> arg .)
    COMMA           reduce using rule 19 (parametres -> arg .)


state 58

    (29) expression_arithmetic -> LPAREN expression_arithmetic . RPAREN
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

    RPAREN          shift and go to state 81
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65


state 59

    (30) expression_arithmetic -> NUMBER .

    RPAREN          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    PLUS            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    MINUS           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    TIMES           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    DIVIDE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    COMMA           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    DRAW            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    MOVE            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    ROTATE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    COLOR           reduce using rule 30 (expression_arithmetic -> NUMBER .)
    VARIABLE        reduce using rule 30 (expression_arithmetic -> NUMBER .)
    IDENTIFIER      reduce using rule 30 (expression_arithmetic -> NUMBER .)
    IF              reduce using rule 30 (expression_arithmetic -> NUMBER .)
    FOR             reduce using rule 30 (expression_arithmetic -> NUMBER .)
    LBRACE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    $end            reduce using rule 30 (expression_arithmetic -> NUMBER .)
    RBRACE          reduce using rule 30 (expression_arithmetic -> NUMBER .)
    SEMICOLON       reduce using rule 30 (expression_arithmetic -> NUMBER .)


state 60

    (31) expression_arithmetic -> IDENTIFIER .

    RPAREN          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    PLUS            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    MINUS           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    TIMES           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    DIVIDE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    COMMA           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    DRAW            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    MOVE            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    ROTATE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    COLOR           reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    VARIABLE        reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    IF              reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    FOR             reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    LBRACE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    $end            reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    RBRACE          reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)
    SEMICOLON       reduce using rule 31 (expression_arithmetic -> IDENTIFIER .)


state 61

    (32) deplacement -> MOVE LPAREN arg COMMA . arg RPAREN
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    arg                            shift and go to state 82
    expression_arithmetic          shift and go to state 43

state 62

    (25) expression_arithmetic -> expression_arithmetic PLUS . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 37
    NUMBER          shift and go to state 59
    IDENTIFIER      shift and go to state 60

    expression_arithmetic          shift and go to state 83

state 63

    (26) expression_arithmetic -> expression_arithmetic MINUS . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 37
    NUMBER          shift and go to state 59
    IDENTIFIER      shift and go to state 60

    expression_arithmetic          shift and go to state 84

state 64

    (27) expression_arithmetic -> expression_arithmetic TIMES . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 37
    NUMBER          shift and go to state 59
    IDENTIFIER      shift and go to state 60

    expression_arithmetic          shift and go to state 85

state 65

    (28) expression_arithmetic -> expression_arithmetic DIVIDE . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    LPAREN          shift and go to state 37
    NUMBER          shift and go to state 59
    IDENTIFIER      shift and go to state 60

    expression_arithmetic          shift and go to state 86

state 66

    (33) rotation -> ROTATE LPAREN arg RPAREN .

    DRAW            reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    MOVE            reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    ROTATE          reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    COLOR           reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    VARIABLE        reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    IDENTIFIER      reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    IF              reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    FOR             reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    LBRACE          reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    $end            reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)
    RBRACE          reduce using rule 33 (rotation -> ROTATE LPAREN arg RPAREN .)


state 67

    (34) couleur -> COLOR LPAREN arg RPAREN .

    DRAW            reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    MOVE            reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    ROTATE          reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    COLOR           reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    VARIABLE        reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    IDENTIFIER      reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    IF              reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    FOR             reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    LBRACE          reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    $end            reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)
    RBRACE          reduce using rule 34 (couleur -> COLOR LPAREN arg RPAREN .)


state 68

    (35) assignation -> VARIABLE IDENTIFIER EQUALS arg .

    DRAW            reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    MOVE            reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    ROTATE          reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    COLOR           reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    VARIABLE        reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    IDENTIFIER      reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    IF              reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    FOR             reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    LBRACE          reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    $end            reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    RBRACE          reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)
    SEMICOLON       reduce using rule 35 (assignation -> VARIABLE IDENTIFIER EQUALS arg .)


state 69

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN . bloc ELSE bloc
    (43) conditionnelle -> IF LPAREN expression_logique RPAREN . bloc
    (41) bloc -> . LBRACE programme RBRACE

    LBRACE          shift and go to state 20

    bloc                           shift and go to state 87

state 70

    (44) expression_logique -> valeur operateur_comparaison . valeur
    (45) expression_logique -> valeur operateur_comparaison . BOOLEAN
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    BOOLEAN         shift and go to state 89
    NUMBER          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    STRING          shift and go to state 53

    valeur                         shift and go to state 88

state 71

    (48) operateur_comparaison -> EQ .

    BOOLEAN         reduce using rule 48 (operateur_comparaison -> EQ .)
    NUMBER          reduce using rule 48 (operateur_comparaison -> EQ .)
    IDENTIFIER      reduce using rule 48 (operateur_comparaison -> EQ .)
    STRING          reduce using rule 48 (operateur_comparaison -> EQ .)


state 72

    (49) operateur_comparaison -> NEQ .

    BOOLEAN         reduce using rule 49 (operateur_comparaison -> NEQ .)
    NUMBER          reduce using rule 49 (operateur_comparaison -> NEQ .)
    IDENTIFIER      reduce using rule 49 (operateur_comparaison -> NEQ .)
    STRING          reduce using rule 49 (operateur_comparaison -> NEQ .)


state 73

    (50) operateur_comparaison -> LT .

    BOOLEAN         reduce using rule 50 (operateur_comparaison -> LT .)
    NUMBER          reduce using rule 50 (operateur_comparaison -> LT .)
    IDENTIFIER      reduce using rule 50 (operateur_comparaison -> LT .)
    STRING          reduce using rule 50 (operateur_comparaison -> LT .)


state 74

    (51) operateur_comparaison -> GT .

    BOOLEAN         reduce using rule 51 (operateur_comparaison -> GT .)
    NUMBER          reduce using rule 51 (operateur_comparaison -> GT .)
    IDENTIFIER      reduce using rule 51 (operateur_comparaison -> GT .)
    STRING          reduce using rule 51 (operateur_comparaison -> GT .)


state 75

    (52) operateur_comparaison -> LE .

    BOOLEAN         reduce using rule 52 (operateur_comparaison -> LE .)
    NUMBER          reduce using rule 52 (operateur_comparaison -> LE .)
    IDENTIFIER      reduce using rule 52 (operateur_comparaison -> LE .)
    STRING          reduce using rule 52 (operateur_comparaison -> LE .)


state 76

    (53) operateur_comparaison -> GE .

    BOOLEAN         reduce using rule 53 (operateur_comparaison -> GE .)
    NUMBER          reduce using rule 53 (operateur_comparaison -> GE .)
    IDENTIFIER      reduce using rule 53 (operateur_comparaison -> GE .)
    STRING          reduce using rule 53 (operateur_comparaison -> GE .)


state 77

    (46) expression_logique -> BOOLEAN operateur_comparaison . valeur
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    NUMBER          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    STRING          shift and go to state 53
    BOOLEAN         shift and go to state 90

    valeur                         shift and go to state 91

state 78

    (54) boucle -> FOR LPAREN assignation SEMICOLON . expression_logique SEMICOLON modification RPAREN bloc
    (44) expression_logique -> . valeur operateur_comparaison valeur
    (45) expression_logique -> . valeur operateur_comparaison BOOLEAN
    (46) expression_logique -> . BOOLEAN operateur_comparaison valeur
    (47) expression_logique -> . BOOLEAN
    (37) valeur -> . NUMBER
    (38) valeur -> . IDENTIFIER
    (39) valeur -> . STRING
    (40) valeur -> . BOOLEAN

    BOOLEAN         shift and go to state 50
    NUMBER          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    STRING          shift and go to state 53

    expression_logique             shift and go to state 92
    valeur                         shift and go to state 49

state 79

    (12) dessin -> DRAW forme LPAREN parametres RPAREN .

    DRAW            reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    MOVE            reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    ROTATE          reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    COLOR           reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    VARIABLE        reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    IDENTIFIER      reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    IF              reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    FOR             reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    LBRACE          reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    $end            reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)
    RBRACE          reduce using rule 12 (dessin -> DRAW forme LPAREN parametres RPAREN .)


state 80

    (18) parametres -> parametres COMMA . arg
    (20) arg -> . NUMBER
    (21) arg -> . IDENTIFIER
    (22) arg -> . STRING
    (23) arg -> . BOOLEAN
    (24) arg -> . expression_arithmetic
    (25) expression_arithmetic -> . expression_arithmetic PLUS expression_arithmetic
    (26) expression_arithmetic -> . expression_arithmetic MINUS expression_arithmetic
    (27) expression_arithmetic -> . expression_arithmetic TIMES expression_arithmetic
    (28) expression_arithmetic -> . expression_arithmetic DIVIDE expression_arithmetic
    (29) expression_arithmetic -> . LPAREN expression_arithmetic RPAREN
    (30) expression_arithmetic -> . NUMBER
    (31) expression_arithmetic -> . IDENTIFIER

    NUMBER          shift and go to state 39
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 41
    BOOLEAN         shift and go to state 42
    LPAREN          shift and go to state 37

    arg                            shift and go to state 93
    expression_arithmetic          shift and go to state 43

state 81

    (29) expression_arithmetic -> LPAREN expression_arithmetic RPAREN .

    PLUS            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    MINUS           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    TIMES           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    DIVIDE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    COMMA           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    RPAREN          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    DRAW            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    MOVE            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    ROTATE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    COLOR           reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    VARIABLE        reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    IF              reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    FOR             reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    LBRACE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    $end            reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    RBRACE          reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)
    SEMICOLON       reduce using rule 29 (expression_arithmetic -> LPAREN expression_arithmetic RPAREN .)


state 82

    (32) deplacement -> MOVE LPAREN arg COMMA arg . RPAREN

    RPAREN          shift and go to state 94


state 83

    (25) expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    RPAREN          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    DRAW            reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    MOVE            reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    ROTATE          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    COLOR           reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    VARIABLE        reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    IDENTIFIER      reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    IF              reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    FOR             reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    LBRACE          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    $end            reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    RBRACE          reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    SEMICOLON       reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65

  ! PLUS            [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 25 (expression_arithmetic -> expression_arithmetic PLUS expression_arithmetic .) ]


state 84

    (26) expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    RPAREN          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    DRAW            reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    MOVE            reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    ROTATE          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    COLOR           reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    VARIABLE        reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    IDENTIFIER      reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    IF              reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    FOR             reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    LBRACE          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    $end            reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    RBRACE          reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    SEMICOLON       reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65

  ! PLUS            [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 26 (expression_arithmetic -> expression_arithmetic MINUS expression_arithmetic .) ]


state 85

    (27) expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    RPAREN          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    DRAW            reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    MOVE            reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    ROTATE          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    COLOR           reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    VARIABLE        reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    IDENTIFIER      reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    IF              reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    FOR             reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    LBRACE          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    $end            reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    RBRACE          reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    SEMICOLON       reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65

  ! PLUS            [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 27 (expression_arithmetic -> expression_arithmetic TIMES expression_arithmetic .) ]


state 86

    (28) expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .
    (25) expression_arithmetic -> expression_arithmetic . PLUS expression_arithmetic
    (26) expression_arithmetic -> expression_arithmetic . MINUS expression_arithmetic
    (27) expression_arithmetic -> expression_arithmetic . TIMES expression_arithmetic
    (28) expression_arithmetic -> expression_arithmetic . DIVIDE expression_arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    RPAREN          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    DRAW            reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    MOVE            reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    ROTATE          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    COLOR           reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    VARIABLE        reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    IDENTIFIER      reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    IF              reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    FOR             reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    LBRACE          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    $end            reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    RBRACE          reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    SEMICOLON       reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65

  ! PLUS            [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]
  ! MINUS           [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]
  ! TIMES           [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]
  ! DIVIDE          [ reduce using rule 28 (expression_arithmetic -> expression_arithmetic DIVIDE expression_arithmetic .) ]


state 87

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN bloc . ELSE bloc
    (43) conditionnelle -> IF LPAREN expression_logique RPAREN bloc .

    ELSE            shift and go to state 95
    DRAW            reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    MOVE            reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    ROTATE          reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    COLOR           reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    VARIABLE        reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    IDENTIFIER      reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    IF              reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    FOR             reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    LBRACE          reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    $end            reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)
    RBRACE          reduce using rule 43 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc .)


state 88

    (44) expression_logique -> valeur operateur_comparaison valeur .

    RPAREN          reduce using rule 44 (expression_logique -> valeur operateur_comparaison valeur .)
    SEMICOLON       reduce using rule 44 (expression_logique -> valeur operateur_comparaison valeur .)


state 89

    (45) expression_logique -> valeur operateur_comparaison BOOLEAN .
    (40) valeur -> BOOLEAN .

  ! reduce/reduce conflict for RPAREN resolved using rule 40 (valeur -> BOOLEAN .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 40 (valeur -> BOOLEAN .)
    RPAREN          reduce using rule 40 (valeur -> BOOLEAN .)
    SEMICOLON       reduce using rule 40 (valeur -> BOOLEAN .)

  ! RPAREN          [ reduce using rule 45 (expression_logique -> valeur operateur_comparaison BOOLEAN .) ]
  ! SEMICOLON       [ reduce using rule 45 (expression_logique -> valeur operateur_comparaison BOOLEAN .) ]


state 90

    (40) valeur -> BOOLEAN .

    RPAREN          reduce using rule 40 (valeur -> BOOLEAN .)
    SEMICOLON       reduce using rule 40 (valeur -> BOOLEAN .)


state 91

    (46) expression_logique -> BOOLEAN operateur_comparaison valeur .

    RPAREN          reduce using rule 46 (expression_logique -> BOOLEAN operateur_comparaison valeur .)
    SEMICOLON       reduce using rule 46 (expression_logique -> BOOLEAN operateur_comparaison valeur .)


state 92

    (54) boucle -> FOR LPAREN assignation SEMICOLON expression_logique . SEMICOLON modification RPAREN bloc

    SEMICOLON       shift and go to state 96


state 93

    (18) parametres -> parametres COMMA arg .

    RPAREN          reduce using rule 18 (parametres -> parametres COMMA arg .)
    COMMA           reduce using rule 18 (parametres -> parametres COMMA arg .)


state 94

    (32) deplacement -> MOVE LPAREN arg COMMA arg RPAREN .

    DRAW            reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    MOVE            reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    ROTATE          reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    COLOR           reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    VARIABLE        reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    IDENTIFIER      reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    IF              reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    FOR             reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    LBRACE          reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    $end            reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)
    RBRACE          reduce using rule 32 (deplacement -> MOVE LPAREN arg COMMA arg RPAREN .)


state 95

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE . bloc
    (41) bloc -> . LBRACE programme RBRACE

    LBRACE          shift and go to state 20

    bloc                           shift and go to state 97

state 96

    (54) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON . modification RPAREN bloc
    (36) modification -> . IDENTIFIER EQUALS arg

    IDENTIFIER      shift and go to state 17

    modification                   shift and go to state 98

state 97

    (42) conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .

    DRAW            reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    MOVE            reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    ROTATE          reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    COLOR           reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    VARIABLE        reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    IDENTIFIER      reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    IF              reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    FOR             reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    LBRACE          reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    $end            reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)
    RBRACE          reduce using rule 42 (conditionnelle -> IF LPAREN expression_logique RPAREN bloc ELSE bloc .)


state 98

    (54) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification . RPAREN bloc

    RPAREN          shift and go to state 99


state 99

    (54) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN . bloc
    (41) bloc -> . LBRACE programme RBRACE

    LBRACE          shift and go to state 20

    bloc                           shift and go to state 100

state 100

    (54) boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .

    DRAW            reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    MOVE            reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    ROTATE          reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    COLOR           reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    VARIABLE        reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    IDENTIFIER      reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    IF              reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    FOR             reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    LBRACE          reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    $end            reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)
    RBRACE          reduce using rule 54 (boucle -> FOR LPAREN assignation SEMICOLON expression_logique SEMICOLON modification RPAREN bloc .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ in state 50 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 50 resolved as shift
WARNING: shift/reduce conflict for LT in state 50 resolved as shift
WARNING: shift/reduce conflict for GT in state 50 resolved as shift
WARNING: shift/reduce conflict for LE in state 50 resolved as shift
WARNING: shift/reduce conflict for GE in state 50 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 84 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 85 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 85 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 86 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 86 resolved as shift
WARNING: reduce/reduce conflict in state 39 resolved using rule (arg -> NUMBER)
WARNING: rejected rule (expression_arithmetic -> NUMBER) in state 39
WARNING: reduce/reduce conflict in state 40 resolved using rule (arg -> IDENTIFIER)
WARNING: rejected rule (expression_arithmetic -> IDENTIFIER) in state 40
WARNING: reduce/reduce conflict in state 89 resolved using rule (valeur -> BOOLEAN)
WARNING: rejected rule (expression_logique -> valeur operateur_comparaison BOOLEAN) in state 89
WARNING: Rule (expression_logique -> valeur operateur_comparaison BOOLEAN) is never reduced
